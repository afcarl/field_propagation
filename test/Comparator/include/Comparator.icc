#include "G4MagIntegratorDriver.hh"

template <class testStepper, class refStepper>
void Comparator::compare(
        const G4double stepLen, const G4int nSteps, Mode mode)
{
    const int NCOMP = G4FieldTrack::ncompSVEC;

    G4double yIn[NCOMP], yOut[NCOMP], yErr[NCOMP], dydx[NCOMP];
    G4double yInRef[NCOMP], yOutRef[NCOMP], yErrRef[NCOMP], dydxRef[NCOMP];

    testStepper testSt(fequation.get());
    refStepper refSt(fequation.get());
    fdiffSteps = 0;

    for (G4int i = 0; i < nSteps; ++i) {
        ftestTrack->DumpToArray(yIn);
        frefTrack->DumpToArray(yInRef);

        testSt.RightHandSide(yIn, dydx);
        testSt.Stepper(yIn, dydx, stepLen, yOut, yErr);

        refSt.RightHandSide(yInRef, dydxRef);
        refSt.Stepper(yInRef, dydxRef, stepLen, yOutRef, yErrRef);

        ftestTrack->LoadFromArray(yOut, fncomp);
        frefTrack->LoadFromArray(yOutRef, fncomp);

        crossCheck (yOut, yOutRef, mode);
    }


    if (mode == Mode::Silent){
        G4cout<<"diffSteps# "<<fdiffSteps<<" maxDiff "<<fmaxDiff<<G4endl;
    }
}

template <class TestStepper, class RefStepper>
void Comparator::compareWithDriver(
    const G4double stepLength, const int nSteps, Mode mode)
{
    const int NCOMP = G4FieldTrack::ncompSVEC;

    G4double y[NCOMP], dydx[NCOMP];
    G4double trackLength = 0, htry = stepLength, epsRelMax = fprecision/stepLength, hdid = 0, hnext  = 0;

    G4double yRef[NCOMP];

    //StandardDriver<TestStepper> testDriver(equation_);

    TestStepper testStepper(fequation.get());
    G4MagInt_Driver testDriver(1e-4, &testStepper);

    RefStepper refStepper(fequation.get());
    G4MagInt_Driver refDriver(1e-4, &refStepper);

    std::ofstream out("res.txt");

    fdiffSteps = 0;
    for (int i = 0; i < nSteps; ++i) {
        ftestTrack->DumpToArray(y);
        testDriver.GetStepper()->RightHandSide(y, dydx);

        testDriver.OneGoodStep(
            y, dydx, trackLength, htry, epsRelMax, hdid, hnext);

        out << hdid << std::endl;

        refDriver.AccurateAdvance(*frefTrack, hdid, epsRelMax, htry);

        ftestTrack->LoadFromArray(y, NCOMP);
        frefTrack->DumpToArray(yRef);

        crossCheck (y, yRef, mode);
    }

    if (mode == Mode::Silent){
        G4cout<<"diffSteps# "<<fdiffSteps<<" maxDiff "<<fmaxDiff<<G4endl;
    }
}

/*
template <class refStepper>
void Comparator::CompareWithBS(const G4double path, const G4int verb)
{
    refStepper refSt(equation_.get());
    G4VIntegrationDriver* refDriver = new G4MagInt_Driver(hmin_, &refSt); //deleted by G4ChordFinder
    G4ChordFinder refChordFinder(refDriver);
    G4VIntegrationDriver* BSDriver = new BulirschStoerDriver(hmin,equation_.get());
    //G4VIntegrationDriver* BSDriver = new G4MagInt_Driver(hmin,&rk4);
    //BulirschStoerDenseDriver* BSDriver = new BulirschStoerDenseDriver(hmin,equation);

    G4ChordFinder testChordFinder(BSDriver);
    //refChordFinder.SetDeltaChord(1*cm);
    //testChordFinder.SetDeltaChord(1*cm);

    //unused variables for G4ChordFinder
    const G4ThreeVector vec(0,0,0);
    G4double latestSafetyRadius = 0;

    G4double pathRest = path;
    G4double step;
    G4double yRef[ncomp_], yTest[ncomp_];
    std::ofstream outRef("outRef.txt");
    std::ofstream outBS("outBS.txt");
    G4CachedMagneticField* cachedField = static_cast<G4CachedMagneticField*>(field);

    G4double eps = precision;
    G4double pathRest2 = pathRest;
    while (pathRest > hmin){
        step = testChordFinder.AdvanceChordLimited(*testTrack,pathRest2,eps,vec,latestSafetyRadius);
        pathRest -= step;
        G4double tempRest = step;
        while(tempRest > hmin)
        {
          G4double h = refChordFinder.AdvanceChordLimited(*refTrack,tempRest,eps,vec,latestSafetyRadius);
          tempRest -= h;
        }
        refTrack->DumpToArray(yRef);
        testTrack->DumpToArray(yTest);
        CrossCheck(yTest,yRef,Default);

        outRef << yRef[0]<< "  "<<yRef[1]<< "  "<<yRef[2] << G4endl;
        outBS << yTest[0]<< "  "<<yTest[1]<< "  "<<yTest[2] << G4endl;
    }


    while (pathRest > hmin){
        step = refChordFinder.AdvanceChordLimited(*refTrack,pathRest,eps,vec,latestSafetyRadius);
        pathRest -= step;
        refTrack->DumpToArray(y);
        outRef << y[0]<< "  "<<y[1]<< "  "<<y[2] << G4endl;
    }
    G4cout<<"ref calls: "<<cachedField->GetCountCalls()<<G4endl;
    cachedField->ClearCounts();
    //refChordFinder.PrintStatistics();


    pathRest = path;
    while (pathRest > hmin){
        step = testChordFinder.AdvanceChordLimited(*testTrack,pathRest,eps,vec,latestSafetyRadius);
        pathRest -= step;
        testTrack->DumpToArray(y);
        outBS << y[0]<< "  "<<y[1]<< "  "<<y[2] << G4endl;
    }
    G4cout<<"BS calls: "<<cachedField->GetCountCalls()<<G4endl;
}

*/
