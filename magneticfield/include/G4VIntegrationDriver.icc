//setters
inline void G4VIntegrationDriver::SetMinimumStep(G4double newStep)
{fMinimumStep = newStep;}

inline void G4VIntegrationDriver::SetVerboseLevel(G4int VerboseLevel)
{fVerboseLevel = VerboseLevel;}

inline void G4VIntegrationDriver::SetEquationOfMotion(G4EquationOfMotion* pEquation)
{
	if (fpStepper == nullptr) fpEquation = pEquation;
	else fpStepper->SetEquationOfMotion(pEquation);
}

inline void G4VIntegrationDriver::SetStepper(G4MagIntegratorStepper* pStepper)
{fpStepper = pStepper;}

inline void G4VIntegrationDriver::SetInterpolationInterval(const G4InterpolationInterval& interval)
{fInterpolationInterval = interval;}

//getters
inline G4EquationOfMotion* G4VIntegrationDriver::GetEquationOfMotion() const
{return fpStepper == nullptr ? fpEquation : fpStepper->GetEquationOfMotion();}

inline const G4MagIntegratorStepper* G4VIntegrationDriver::GetStepper() const
{return fpStepper;}

inline G4MagIntegratorStepper* G4VIntegrationDriver::GetStepper()
{return fpStepper;}

inline G4double G4VIntegrationDriver::GetMinimumStep() const
{return fMinimumStep;}

inline G4int G4VIntegrationDriver::GetNumberOfVariables() const
{return fNoIntegrationVariables;}

inline G4double G4VIntegrationDriver::GetVerboseLevel() const
{return fVerboseLevel;}

inline void G4VIntegrationDriver::GetDerivatives(const G4FieldTrack& track, G4double dydx[]) const
{
	G4double y[G4FieldTrack::ncompSVEC];
	track.DumpToArray(y);
	GetEquationOfMotion()->RightHandSide(y, dydx);
}

inline G4InterpolationInterval& G4VIntegrationDriver::GetInterpolationInterval()
{return fInterpolationInterval;}

